/**
 * Webpack 5 plugin to remove empty scripts generated by usage only style in entries.
 */

const NAME = 'webpack-remove-empty-scripts';

const defaultOptions = {
  extensions: ['css', 'scss', 'sass', 'less', 'styl'],
  scriptExtensions: ['js', 'mjs'],
  silent: false,
  ignore: undefined,
};

class WebpackRemoveEmptyScriptsPlugin {
  constructor(options) {
    this.apply = this.apply.bind(this);
    this.options = Object.assign({}, defaultOptions, options);
  }

  apply(compiler) {
    const extensionsWithoutDots = this.options.extensions.map(e =>
        e[0] === '.' ? e.substring(1) : e
    );

    const patternOneOfExtensions = extensionsWithoutDots
        .map(ext => escapeRegExp(ext))
        .join('|');

    const reStylesResource = new RegExp(
        `[.](${patternOneOfExtensions})([?].*)?$`
    );

    compiler.hooks.compilation.tap(NAME, compilation => {
      const resourcesCache = [];

      compilation.hooks.chunkAsset.tap(NAME, (chunk, file) => {
        const isNotScript = defaultOptions.scriptExtensions.every((ext) => file.lastIndexOf('.' + ext) < 0);
        if (isNotScript) return;

        // has entry modules
        if (compilation.chunkGraph.getNumberOfEntryModules(chunk) < 1) return;
        const entryModules = Array.from(compilation.chunkGraph.getChunkEntryModulesIterable(chunk));
        if (entryModules.length < 1) return;

        const entryModule = entryModules[0];
        const entryResources = collectEntryResources(compilation, entryModule, resourcesCache);

        const resources = this.options.ignore
            ? entryResources.filter(res => !res.match(this.options.ignore))
            : entryResources;

        const isStyleOnly =
            resources.length &&
            resources.every(resource => reStylesResource.test(resource));

        if (isStyleOnly) {
          if (!this.options.silent) {
            console.log('[remove-empty-scripts] remove empty js from style only entry: ' + file);
          }
          
          chunk.files.delete(file);
          delete compilation.assets[file];
        }
      });
    });
  }
}

function collectEntryResources(compilation, module, cache) {
  const index = compilation.moduleGraph.getPreOrderIndex(module),
      resources = [];

  // index of module is unique per compilation
  // module.id can be null, not used here
  if (cache[index] !== undefined) {

    return cache[index];
  }

  if (typeof module.resource == 'string') {
    const resources = [module.resource];
    cache[index] = resources;

    return resources;
  }

  if (module.dependencies) {
    module.dependencies.forEach(dep => {
      if(dep) {
        const module = compilation.moduleGraph.getModule(dep),
            originModule = compilation.moduleGraph.getParentModule(dep),
            nextModule = module || originModule;

        if (nextModule) {
          const depResources = collectEntryResources(compilation, nextModule, cache);

          for (let index = 0, length = depResources.length; index !== length; index++) {
            resources.push(depResources[index]);
          }
        }
      }
    });
  }
  cache[index] = resources;

  return resources;
}

// https://github.com/lodash/lodash/blob/4.17.11/lodash.js#L14274
const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
const reHasRegExpChar = RegExp(reRegExpChar.source);

function escapeRegExp(string) {
  string = String(string);

  return string && reHasRegExpChar.test(string)
      ? string.replace(reRegExpChar, '\\$&')
      : string;
}

module.exports = WebpackRemoveEmptyScriptsPlugin;